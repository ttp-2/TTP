<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Babylon.js FPS with Grass and Flat Sky</title>
<style>
  html, body {
    margin: 0; padding: 0; overflow: hidden; width: 100%; height: 100%;
    background: #87ceeb;
  }
  #renderCanvas {
    width: 100%; height: 100%; touch-action: none;
    display: block;
    cursor: grab;
  }
  #renderCanvas:active {
    cursor: grabbing;
  }
</style>
</head>
<body>
<canvas id="renderCanvas"></canvas>

<script src="https://cdn.babylonjs.com/babylon.js"></script>
<script>
  const canvas = document.getElementById("renderCanvas");
  const engine = new BABYLON.Engine(canvas, true);
  const scene = new BABYLON.Scene(engine);

  // === Sky Background ===
  const skyPlane = BABYLON.MeshBuilder.CreatePlane("skyPlane", {width: 20000, height: 10000}, scene);
  skyPlane.position = new BABYLON.Vector3(0, 5000, 10000); // very far forward
  skyPlane.rotation = new BABYLON.Vector3(0, Math.PI, 0); // face the player
  const skyMaterial = new BABYLON.StandardMaterial("skyMat", scene);
  skyMaterial.diffuseTexture = new BABYLON.Texture("sky.png", scene);
  skyMaterial.backFaceCulling = false;
  skyPlane.material = skyMaterial;
  skyPlane.isPickable = false;
  skyPlane.receiveShadows = false;
  skyPlane.checkCollisions = false;

  // === Ground ===
  const ground = BABYLON.MeshBuilder.CreateGround("ground", {
    width: 10000,
    height: 10000
  }, scene);
  ground.position.y = 0;
  ground.checkCollisions = true;

  const groundMaterial = new BABYLON.StandardMaterial("groundMat", scene);
  groundMaterial.diffuseTexture = new BABYLON.Texture("grass.png", scene);
  groundMaterial.diffuseTexture.uScale = 1000;
  groundMaterial.diffuseTexture.vScale = 1000;
  ground.material = groundMaterial;

  // === Player (invisible box for physics) ===
  const player = BABYLON.MeshBuilder.CreateBox("player", { size: 1 }, scene);
  player.position.y = 0.5;
  player.isVisible = false;
  player.checkCollisions = true;
  player.ellipsoid = new BABYLON.Vector3(0.5, 0.9, 0.5);
  player.ellipsoidOffset = new BABYLON.Vector3(0, 0.9, 0);

  // === Camera ===
  const camera = new BABYLON.UniversalCamera("fpsCamera", player.position.add(new BABYLON.Vector3(0, 0.9, 0)), scene);
  camera.attachControl(canvas, true);
  camera.checkCollisions = false;
  camera.applyGravity = false;

  // === Light ===
  const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);
  light.intensity = 0.9;

  // === Scene Gravity ===
  scene.gravity = new BABYLON.Vector3(0, -0.2, 0);
  scene.collisionsEnabled = true;

  // === Input Map ===
  const inputMap = {};
  scene.actionManager = new BABYLON.ActionManager(scene);
  scene.actionManager.registerAction(new BABYLON.ExecuteCodeAction(BABYLON.ActionManager.OnKeyDownTrigger, evt => {
    inputMap[evt.sourceEvent.key.toLowerCase()] = true;
  }));
  scene.actionManager.registerAction(new BABYLON.ExecuteCodeAction(BABYLON.ActionManager.OnKeyUpTrigger, evt => {
    inputMap[evt.sourceEvent.key.toLowerCase()] = false;
  }));

  // === Pointer Lock ===
  canvas.addEventListener("click", () => {
    canvas.requestPointerLock = canvas.requestPointerLock || canvas.msRequestPointerLock || canvas.mozRequestPointerLock || canvas.webkitRequestPointerLock;
    if (canvas.requestPointerLock) {
      canvas.requestPointerLock();
    }
  });

  // === Physics ===
  let playerVelocity = new BABYLON.Vector3(0, 0, 0);
  const baseSpeed = 0.15;
  const jumpForce = 0.3;
  let isOnGround = false;

  scene.onBeforeRenderObservable.add(() => {
    const runMultiplier = inputMap["shift"] ? 3 : 1;
    const speed = baseSpeed * runMultiplier;

    const forward = camera.getDirection(BABYLON.Axis.Z).scaleInPlace(speed);
    const right = camera.getDirection(BABYLON.Axis.X).scaleInPlace(speed);

    playerVelocity.x = 0;
    playerVelocity.z = 0;

    if (inputMap["w"]) playerVelocity.addInPlace(forward);
    if (inputMap["s"]) playerVelocity.subtractInPlace(forward);
    if (inputMap["a"]) playerVelocity.subtractInPlace(right);
    if (inputMap["d"]) playerVelocity.addInPlace(right);

    player.position.x += playerVelocity.x;
    player.position.z += playerVelocity.z;

    // Gravity
    if (!isOnGround) {
      playerVelocity.y += scene.gravity.y;
      player.position.y += playerVelocity.y;
    }

    // Ground check
    if (player.position.y <= 0.9) {
      player.position.y = 0.9;
      playerVelocity.y = 0;
      isOnGround = true;
    } else {
      isOnGround = false;
    }

    // Jump
    if (inputMap[" "] && isOnGround) {
      playerVelocity.y = jumpForce;
      isOnGround = false;
    }

    // Camera follows player at eye level
    camera.position.copyFrom(player.position).addInPlace(new BABYLON.Vector3(0, 0.9, 0));
  });

  // === Render ===
  window.addEventListener("resize", () => engine.resize());
  engine.runRenderLoop(() => scene.render());
</script>
</body>
</html>
